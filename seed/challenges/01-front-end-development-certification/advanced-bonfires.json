{
  "name": "Advanced Algorithm Scripting",
  "order": 12,
  "time": "50 hours",
  "helpRoom": "HelpJavaScript",
  "challenges": [
    {
      "id": "aff0395860f5d3034dc0bfc9",
      "title": "Validate US Telephone Numbers",
      "description": [
        "如果传入字符串是一个有效的美国电话号码，则返回 <code>true</code>.",
        "用户可以在表单中填入一个任意有效美国电话号码. 下面是一些有效号码的例子(还有下面测试时用到的一些变体写法):",
        "<blockquote>555-555-5555\n(555)555-5555\n(555) 555-5555\n555 555 5555\n5555555555\n1 555 555 5555</blockquote>",
        "在本节中你会看见如 <code>800-692-7753</code> or <code>8oo-six427676;laskdjf</code>这样的字符串. 你的任务就是验证前面给出的字符串是否是有效的美国电话号码. 区号是必须有的. 如果字符串中给出了国家代码, 你必须验证其是 <code>1</code>.  如果号码有效就返回 <code>true</code> ; 否则返回 <code>false</code>.",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function telephoneCheck(str) {",
        "  // 祝你好运",
        "  return true;",
        "}",
        "",
        "",
        "",
        "telephoneCheck(\"555-555-5555\");"
      ],
      "solutions": [
        "var re = /^(?:(?:\\+?1\\s*(?:[.-]\\s*)?)?(?:\\(\\s*([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9])\\s*\\)|([2-9]1[02-9]|[2-9][02-8]1|[2-9][02-8][02-9]))\\s*(?:[.-]\\s*)?)?([2-9]1[02-9]|[2-9][02-9]1|[2-9][02-9]{2})\\s*(?:[.-]\\s*)?([0-9]{4})$/;\n\nfunction telephoneCheck(str) {\n  return !!str.match(re);\n}\n\ntelephoneCheck(\"555-555-5555\");"
      ],
      "tests": [
        "assert(typeof telephoneCheck(\"555-555-5555\") === \"boolean\", 'message: <code>telephoneCheck(\"555-555-5555\")</code> 应该返回一个布尔值.');",
        "assert(telephoneCheck(\"1 555-555-5555\") === true, 'message: <code>telephoneCheck(\"1 555-555-5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"1 (555) 555-5555\") === true, 'message: <code>telephoneCheck(\"1 (555) 555-5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"5555555555\") === true, 'message: <code>telephoneCheck(\"5555555555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"555-555-5555\") === true, 'message: <code>telephoneCheck(\"555-555-5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"(555)555-5555\") === true, 'message: <code>telephoneCheck(\"(555)555-5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"1(555)555-5555\") === true, 'message: <code>telephoneCheck(\"1(555)555-5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"1 555)555-5555\") === false, 'message: <code>telephoneCheck(\"1 555)555-5555\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"1 555 555 5555\") === true, 'message: <code>telephoneCheck(\"1 555 555 5555\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"1 456 789 4444\") === true, 'message: <code>telephoneCheck(\"1 456 789 4444\")</code> 应该返回 true.');",
        "assert(telephoneCheck(\"123**&!!asdf#\") === false, 'message: <code>telephoneCheck(\"123**&!!asdf#\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"55555555\") === false, 'message: <code>telephoneCheck(\"55555555\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"(6505552368)\") === false, 'message: <code>telephoneCheck(\"(6505552368)\")</code> 应该返回 false');",
        "assert(telephoneCheck(\"2 (757) 622-7382\") === false, 'message: <code>telephoneCheck(\"2 (757) 622-7382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"0 (757) 622-7382\") === false, 'message: <code>telephoneCheck(\"0 (757) 622-7382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"-1 (757) 622-7382\") === false, 'message: <code>telephoneCheck(\"-1 (757) 622-7382\")</code> 应该返回 false');",
        "assert(telephoneCheck(\"2 757 622-7382\") === false, 'message: <code>telephoneCheck(\"2 757 622-7382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"10 (757) 622-7382\") === false, 'message: <code>telephoneCheck(\"10 (757) 622-7382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"27576227382\") === false, 'message: <code>telephoneCheck(\"27576227382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"(275)76227382\") === false, 'message: <code>telephoneCheck(\"(275)76227382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"2(757)6227382\") === false, 'message: <code>telephoneCheck(\"2(757)6227382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"2(757)622-7382\") === false, 'message: <code>telephoneCheck(\"2(757)622-7382\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"555)-555-5555\") === false, 'message: <code>telephoneCheck(\"555)-555-5555\")</code> 应该返回 false.');",
        "assert(telephoneCheck(\"(555-555-5555\") === false, 'message: <code>telephoneCheck(\"(555-555-5555\")</code> 应该返回 false.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "RegExp"
      ],
      "challengeType": 5
    },
    {
      "id": "a3f503de51cf954ede28891d",
      "title": "Symmetric Difference",
      "description": [
        "创建一个函数，接受两个或多个数组，返回所给数组的 <dfn>对等差分(symmetric difference)</dfn> (<code>&xutri;</code> or <code>&oplus;</code>)数组.",
        "给出两个集合 (如集合 <code>A = {1, 2, 3}</code> 和集合 <code>B = {2, 3, 4}</code>), 而数学术语 \"对等差分\" 的集合就是指由所有只在两个集合其中之一的元素组成的集合(<code>A &xutri; B = C = {1, 4}</code>). 对于传入的额外集合 (如 <code>D = {2, 3}</code>), 你应该安装前面原则求前两个集合的结果与新集合的对等差分集合 (<code>C &xutri; D = {1, 4} &xutri; {2, 3} = {1, 2, 3, 4}</code>).",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function sym(args) {",
        "  return args;",
        "}",
        "",
        "sym([1, 2, 3], [5, 2, 1, 4]);"
      ],
      "solutions": [
        "function sym(args) {\n  var index = -1;\n  var length = arguments.length;\n  var result;\n  while (++index < length) {\n    var array = arguments[index];\n    result = result ? diff(result, array).concat(diff(array, result)) : array;\n  }\n  return result ? uniq(result) : [];\n}\n\nfunction uniq(arr) {\n  var h = Object.create(null);\n  var u = [];\n  arr.forEach(function(v) {\n    if (v in h) return;\n    h[v] = true;\n    u.push(v);\n  });\n  return u;\n}\n\nfunction diff(a, b) {\n  var h = Object.create(null);\n  b.forEach(function(v) {\n    h[v] = true;  \n  });\n  return a.filter(function(v) { return !(v in h);});\n}\nsym([1, 2, 3], [5, 2, 1, 4]);\n"
      ],
      "tests": [
        "assert.sameMembers(sym([1, 2, 3], [5, 2, 1, 4]), [3, 4, 5], 'message: <code>sym([1, 2, 3], [5, 2, 1, 4])</code> 应该返回 <code>[3, 4, 5]</code>.');",
        "assert.equal(sym([1, 2, 3], [5, 2, 1, 4]).length, 3, 'message: <code>sym([1, 2, 3], [5, 2, 1, 4])</code> 应该只包含三个元素.');",
        "assert.sameMembers(sym([1, 2, 5], [2, 3, 5], [3, 4, 5]), [1, 4, 5], 'message: <code>sym([1, 2, 5], [2, 3, 5], [3, 4, 5])</code> 应该返回 <code>[1, 4, 5]</code>');",
        "assert.equal(sym([1, 2, 5], [2, 3, 5], [3, 4, 5]).length, 3, 'message: <code>sym([1, 2, 5], [2, 3, 5], [3, 4, 5])</code> 应该只包含三个元素.');",
        "assert.sameMembers(sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]), [1, 4, 5], 'message: <code>sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])</code> 应该返回 <code>[1, 4, 5]</code>.');",
        "assert.equal(sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]).length, 3, 'message: <code>sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])</code> 应该只包含三个元素.');",
        "assert.sameMembers(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]), [2, 3, 4, 6, 7], 'message: <code>sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])</code> 应该返回 <code>[2, 3, 4, 6, 7]</code>.');",
        "assert.equal(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]).length, 5, 'message: <code>sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])</code> 应该只包含五个元素.');",
        "assert.sameMembers(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1]), [1, 2, 4, 5, 6, 7, 8, 9], 'message: <code>sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])</code> 应该返回 <code>[1, 2, 4, 5, 6, 7, 8, 9]</code>.');",
        "assert.equal(sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1]).length, 8, 'message: <code>sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])</code> 应该只包含八个元素.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Array.reduce()",
        "Symmetric Difference"
      ],
      "challengeType": 5
    },
    {
      "id": "aa2e6f85cab2ab736c9a9b24",
      "title": "Exact Change",
      "description": [
        "设计一个收银程序 <code>checkCashRegister()</code> ，其把购买价格(<code>price</code>)作为第一个参数 , 付款金额 (<code>cash</code>)作为第二个参数, 和收银机中零钱 (<code>cid</code>) 作为第三个参数.",
        "<code>cid</code> 是一个二维数组，存着当前可用的找零.",
        "当收银机中的钱不够找零时返回字符串 <code>\"Insufficient Funds\"</code>. 如果正好则返回字符串 <code>\"Closed\"</code>.",
        "否则, 返回应找回的零钱列表,且由大到小存在二维数组中.",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function checkCashRegister(price, cash, cid) {",
        "  var change;",
        "  return change;",
        "}",
        "",
        "// Example cash-in-drawer array:",
        "// [[\"PENNY\", 1.01],",
        "// [\"NICKEL\", 2.05],",
        "// [\"DIME\", 3.10],",
        "// [\"QUARTER\", 4.25],",
        "// [\"ONE\", 90.00],",
        "// [\"FIVE\", 55.00],",
        "// [\"TEN\", 20.00],",
        "// [\"TWENTY\", 60.00],",
        "// [\"ONE HUNDRED\", 100.00]]",
        "",
        "checkCashRegister(19.50, 20.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]]);"
      ],
      "solutions": [
        "var denom = [\n\t{ name: 'ONE HUNDRED', val: 100.00},\n\t{ name: 'TWENTY', val: 20.00},\n\t{ name: 'TEN', val: 10.00},\n\t{ name: 'FIVE', val: 5.00},\n\t{ name: 'ONE', val: 1.00},\n\t{ name: 'QUARTER', val: 0.25},\n\t{ name: 'DIME', val: 0.10},\n\t{ name: 'NICKEL', val: 0.05},\n\t{ name: 'PENNY', val: 0.01}\n];\n\nfunction checkCashRegister(price, cash, cid) {\n    var change = cash - price;\n    var register = cid.reduce(function(acc, curr) {\n        acc.total += curr[1];\n        acc[curr[0]] = curr[1];\n        return acc;\n    }, {total: 0});\n    if(register.total === change) {\n        return 'Closed';\n    }\n    if(register.total < change) {\n        return 'Insufficient Funds';\n    }\n    var change_arr = denom.reduce(function(acc, curr) {\n        var value = 0;\n        while(register[curr.name] > 0 && change >= curr.val) {\n           change -= curr.val;\n           register[curr.name] -= curr.val;\n           value += curr.val;\n           change = Math.round(change * 100) / 100;\n        }\n        if(value > 0) {\n            acc.push([ curr.name, value ]);\n        }\n        return acc;\n    }, []);\n  if(change_arr.length < 1 || change > 0) {\n    return \"Insufficient Funds\";\n  }\n  return change_arr;\n}"
      ],
      "tests": [
        "assert.isArray(checkCashRegister(19.50, 20.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]]), 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]])</code> 应该返回一个数组.');",
        "assert.isString(checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]), 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]])</code> 应该返回一个字符串.');",
        "assert.isString(checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.50], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]), 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.50], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]])</code> 应该返回一个字符串.');",
        "assert.deepEqual(checkCashRegister(19.50, 20.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]]), [[\"QUARTER\", 0.50]], 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]])</code> 应该返回 <code>[[\"QUARTER\", 0.50]]</code>.');",
        "assert.deepEqual(checkCashRegister(3.26, 100.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]]), [[\"TWENTY\", 60.00], [\"TEN\", 20.00], [\"FIVE\", 15], [\"ONE\", 1], [\"QUARTER\", 0.50], [\"DIME\", 0.20], [\"PENNY\", 0.04]], 'message: <code>checkCashRegister(3.26, 100.00, [[\"PENNY\", 1.01], [\"NICKEL\", 2.05], [\"DIME\", 3.10], [\"QUARTER\", 4.25], [\"ONE\", 90.00], [\"FIVE\", 55.00], [\"TEN\", 20.00], [\"TWENTY\", 60.00], [\"ONE HUNDRED\", 100.00]])</code> 应该返回 <code>[[\"TWENTY\", 60.00], [\"TEN\", 20.00], [\"FIVE\", 15], [\"ONE\", 1], [\"QUARTER\", 0.50], [\"DIME\", 0.20], [\"PENNY\", 0.04]]</code>.');",
        "assert.deepEqual(checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]), \"Insufficient Funds\", 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]])</code> 应该返回 \"Insufficient Funds\".');",
        "assert.deepEqual(checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 1.00], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]), \"Insufficient Funds\", 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.01], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 1.00], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]])</code> 应该返回 \"Insufficient Funds\".');",
        "assert.deepEqual(checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.50], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]]), \"Closed\", 'message: <code>checkCashRegister(19.50, 20.00, [[\"PENNY\", 0.50], [\"NICKEL\", 0], [\"DIME\", 0], [\"QUARTER\", 0], [\"ONE\", 0], [\"FIVE\", 0], [\"TEN\", 0], [\"TWENTY\", 0], [\"ONE HUNDRED\", 0]])</code> 应该返回 \"Closed\".');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Global Object"
      ],
      "challengeType": 5
    },
    {
      "id": "a56138aff60341a09ed6c480",
      "title": "Inventory Update",
      "description": [
        "依照一个存着新进货物的二维数组，更新存着现有库存(在 <code>arr1</code> 中)的二维数组. 如果货物已存在则更新数量 . 如果没有对应货物则把其加入到数组中，更新最新的数量. 返回当前的库存数组，且按货物名称的字母顺序排列.",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function updateInventory(arr1, arr2) {",
        "    // 请保证你的代码考虑到所有情况",
        "    return arr1;",
        "}",
        "",
        "// 仓库库存示例",
        "var curInv = [",
        "    [21, \"Bowling Ball\"],",
        "    [2, \"Dirty Sock\"],",
        "    [1, \"Hair Pin\"],",
        "    [5, \"Microphone\"]",
        "];",
        "",
        "var newInv = [",
        "    [2, \"Hair Pin\"],",
        "    [3, \"Half-Eaten Apple\"],",
        "    [67, \"Bowling Ball\"],",
        "    [7, \"Toothpaste\"]",
        "];",
        "",
        "updateInventory(curInv, newInv);"
      ],
      "solutions": [
        "function updateInventory(arr1, arr2) {\n  arr2.forEach(function(item) {\n    createOrUpdate(arr1, item);\n  });\n  // All inventory must be accounted for or you're fired!\n  return arr1;\n}\n\nfunction createOrUpdate(arr1, item) {\n  var index = -1;\n  while (++index < arr1.length) {\n    if (arr1[index][1] === item[1]) {\n      arr1[index][0] += item[0];\n      return;\n    }\n    if (arr1[index][1] > item[1]) {\n      break;\n    }\n  }\n  arr1.splice(index, 0, item);\n}\n\n// Example inventory lists\nvar curInv = [\n    [21, 'Bowling Ball'],\n    [2, 'Dirty Sock'],\n    [1, 'Hair Pin'],\n    [5, 'Microphone']\n];\n\nvar newInv = [\n    [2, 'Hair Pin'],\n    [3, 'Half-Eaten Apple'],\n    [67, 'Bowling Ball'],\n    [7, 'Toothpaste']\n];\n\nupdateInventory(curInv, newInv);\n"
      ],
      "tests": [
        "assert.isArray(updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]]), 'message: <code>updateInventory()</code> 应该返回一个数组.');",
        "assert.equal(updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]]).length, 6, 'message: <code>updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]]).length</code> 应该返回一个长度为6的数组.');",
        "assert.deepEqual(updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]]), [[88, \"Bowling Ball\"], [2, \"Dirty Sock\"], [3, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [5, \"Microphone\"], [7, \"Toothpaste\"]], 'message: <code>updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]])</code> 应该返回 <code>[[88, \"Bowling Ball\"], [2, \"Dirty Sock\"], [3, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [5, \"Microphone\"], [7, \"Toothpaste\"]]</code>.');",
        "assert.deepEqual(updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], []), [[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], 'message: <code>updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [])</code> 应该返回 <code>[[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]]</code>.');",
        "assert.deepEqual(updateInventory([], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]]), [[67, \"Bowling Ball\"], [2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [7, \"Toothpaste\"]], 'message: <code>updateInventory([], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]])</code> 应该返回 <code>[[67, \"Bowling Ball\"], [2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [7, \"Toothpaste\"]]</code>.');",
        "assert.deepEqual(updateInventory([[0, \"Bowling Ball\"], [0, \"Dirty Sock\"], [0, \"Hair Pin\"], [0, \"Microphone\"]], [[1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [1, \"Bowling Ball\"], [1, \"Toothpaste\"]]), [[1, \"Bowling Ball\"], [0, \"Dirty Sock\"], [1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [0, \"Microphone\"], [1, \"Toothpaste\"]], 'message: <code>updateInventory([[0, \"Bowling Ball\"], [0, \"Dirty Sock\"], [0, \"Hair Pin\"], [0, \"Microphone\"]], [[1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [1, \"Bowling Ball\"], [1, \"Toothpaste\"]])</code> 应该返回 <code>[[1, \"Bowling Ball\"], [0, \"Dirty Sock\"], [1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [0, \"Microphone\"], [1, \"Toothpaste\"]]</code>.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Global Array Object"
      ],
      "challengeType": 5
    },
    {
      "id": "a7bf700cd123b9a54eef01d5",
      "title": "No repeats please",
      "description": [
        "把一个字符串中的字符重新排列生成新的字符串，返回新生成的字符串里没有连续重复字符的字符串个数.连续重复只以单个字符为准",
        "例如, <code>aab</code> 应该返回 2 因为它总共有6中排列 (<code>aab</code>, <code>aab</code>, <code>aba</code>, <code>aba</code>, <code>baa</code>, <code>baa</code>), 但是只有两个 (<code>aba</code> and <code>aba</code>)没有连续重复的字符 (在本例中是 <code>a</code>).",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function permAlone(str) {",
        "  return str;",
        "}",
        "",
        "permAlone('aab');"
      ],
      "solutions": [
        "function permAlone(str) {\n  return permutor(str).filter(function(perm) {\n    return !perm.match(/(.)\\1/g);\n  }).length;\n}\n\nfunction permutor(str) {\n  // http://staff.roguecc.edu/JMiller/JavaScript/permute.html\n  //permArr: Global array which holds the list of permutations\n  //usedChars: Global utility array which holds a list of \"currently-in-use\" characters\n  var permArr = [], usedChars = [];\n  function permute(input) {\n    //convert input into a char array (one element for each character)\n    var i, ch, chars = input.split(\"\");\n    for (i = 0; i < chars.length; i++) {\n      //get and remove character at index \"i\" from char array\n      ch = chars.splice(i, 1);\n      //add removed character to the end of used characters\n      usedChars.push(ch);\n      //when there are no more characters left in char array to add, add used chars to list of permutations\n      if (chars.length === 0) permArr[permArr.length] = usedChars.join(\"\");\n      //send characters (minus the removed one from above) from char array to be permuted\n      permute(chars.join(\"\"));\n      //add removed character back into char array in original position\n      chars.splice(i, 0, ch);\n      //remove the last character used off the end of used characters array\n      usedChars.pop();\n    }\n  }\n  permute(str);\n  return permArr;\n}\n\npermAlone('aab');\n"
      ],
      "tests": [
        "assert.isNumber(permAlone('aab'), 'message: <code>permAlone(\"aab\")</code> 应该返回一个数字.');",
        "assert.strictEqual(permAlone('aab'), 2, 'message: <code>permAlone(\"aab\")</code> 应该返回 2.');",
        "assert.strictEqual(permAlone('aaa'), 0, 'message: <code>permAlone(\"aaa\")</code> 应该返回 0.');",
        "assert.strictEqual(permAlone('aabb'), 8, 'message: <code>permAlone(\"aabb\")</code> 应该返回 8.');",
        "assert.strictEqual(permAlone('abcdefa'), 3600, 'message: <code>permAlone(\"abcdefa\")</code> 应该返回 3600.');",
        "assert.strictEqual(permAlone('abfdefa'), 2640, 'message: <code>permAlone(\"abfdefa\")</code> 应该返回 2640.');",
        "assert.strictEqual(permAlone('zzzzzzzz'), 0, 'message: <code>permAlone(\"zzzzzzzz\")</code> 应该返回 0.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Permutations",
        "RegExp"
      ],
      "challengeType": 5
    },
    {
      "id": "a19f0fbe1872186acd434d5a",
      "title": "Friendly Date Ranges",
      "description": [
        "<strong>让日期区间更友好！</strong>",
        "把常见的日期格式如：<code>YYYY-MM-DD</code> 转换成一种更易读的格式。",
        "易读格式应该是用月份名称代替月份数字，用序数词代替数字来表示天 (<code>1st</code> 代替 <code>1</code>).",
        "记住不要显示那些可以被推测出来的信息: 如果一个日期区间里结束日期与开始日期相差小于一年，则结束日期就不用写年份了；在这种情况下，如果月份开始和结束日期如果在同一个月，则结束日期月份也不用写了。",
        "另外, 如果开始日期年份是当前年份，且结束日期与开始日期小于一年，则开始日期的年份也不用写。",
        "例如:",
        "包含当前年份和相同月份的时候，<code>makeFriendlyDates([\"2017-01-02\", \"2017-01-05\"])</code> 应该返回 <code>[\"January 2nd\",\"5th\"]</code>",
        "不包含当前年份，<code>makeFriendlyDates([\"2003-08-15\", \"2009-09-21\"])</code> 应该返回 <code>[\"August 15th, 2003\", \"September 21st, 2009\"]</code>。",
        "请考虑清楚所有可能出现的情况，包括传入的日期区间是否合理。对于不合理的日期区间，直接返回 <code>undefined</code> 即可",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function makeFriendlyDates(arr) {",
        "  return arr;",
        "}",
        "",
        "makeFriendlyDates(['2017-01-02', '2017-01-05']);"
      ],
      "solutions": [
        "function makeFriendlyDates(arr) {\n    if (getDiff('unixTime', parseDateString(arr[0]), parseDateString(arr[1])) < 0) {\n        return;\n    }\n    var current = new Date();\n    var currentYear = current.getFullYear();\n    var monthArr = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n    function ordinalDay(day){\n        if (day !== 11 && day.toString().slice(-1) === '1') {\n            return day + 'st';\n        } else if (day !== 12 && day.toString().slice(-1) === '2') {\n            return day + 'nd';\n        } else if (day !== 13 && day.toString().slice(-1) === '3') {\n            return day + 'rd';\n        }\n        return day + 'th';\n    }\n    function getDiff(attr, firstDate, secondDate) {\n        var attrMap = {\n            year: 'getFullYear',\n            month: 'getMonth',\n            date: 'getDate',\n            unixTime: 'getTime'\n        }\n        return secondDate[attrMap[attr]]() - firstDate[attrMap[attr]]();\n    }\n    function parseDateString(dateStr) {\n        var dateArr = dateStr.split('-');\n        return new Date(dateArr[0], dateArr[1] - 1, dateArr[2]);\n    }\n    function composeOutput(dateObj) {\n        var output = '';\n        if (dateObj.month) {\n            output += dateObj.month;\n        }\n        if (dateObj.date) {\n            output += (output ? ' ' : '') + dateObj.date;\n        }\n        if (dateObj.year) {\n            output += ', ' + dateObj.year;\n        }\n        return output ? [output] : undefined;\n    }\n    function transformDate(dateString) {\n        var date = parseDateString(dateString);\n        return {\n            month: monthArr[date.getMonth()],\n            date: ordinalDay(date.getDate()),\n            year: date.getFullYear()\n        }\n    }\n    function getResult(firstDate, secondDate) {\n        var parsedFirst = parseDateString(firstDate);\n        var parsedSecond = parseDateString(secondDate);\n        var firstObject = transformDate(firstDate);\n        var secondObject = transformDate(secondDate);\n        if (firstObject.year === currentYear) {\n            firstObject.year = false;\n        }\n        if (getDiff('year', parsedFirst, parsedSecond) === 0) {\n            secondObject.year = false;\n            if (getDiff('month', parsedFirst, parsedSecond) === 0) {\n                secondObject.month = false;\n            }\n            if (getDiff('date', parsedFirst, parsedSecond) === 0) {\n                secondObject.date = false;\n            }\n        } else if (getDiff('year', parsedFirst, parsedSecond) === 1) {\n            if (getDiff('unixTime', parsedFirst, parsedSecond) / (1000 * 3600 * 24) < 365) {\n                secondObject.year = false;\n            }\n        }\n        return [].concat.apply(composeOutput(firstObject), composeOutput(secondObject))\n    }\n    return getResult(arr[0], arr[1])\n}"
      ],
      "tests": [
        "assert.deepEqual(makeFriendlyDates(['2017-01-02', '2017-01-05']), ['January 2nd', '5th'], 'message: <code>makeFriendlyDates([\"2017-01-02\", \"2017-01-05\"])</code> 应该返回 <code>[\"January 2nd\",\"5th\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2017-02-01', '2017-03-03']), ['February 1st', 'March 3rd'], 'message: <code>makeFriendlyDates([\"2017-02-01\", \"2017-03-03\"])</code> 应该返回 <code>[\"February 1st\",\"March 3rd\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2016-05-11', '2017-04-04']), ['May 11th, 2016', 'April 4th'], 'message: <code>makeFriendlyDates([\"2016-05-11\", \"2017-04-04\"])</code> 应该返回 <code>[\"May 11th, 2016\",\"April 4th\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2017-07-12', '2018-06-13']), ['July 12th', 'June 13th'], 'message: <code>makeFriendlyDates([\"2017-07-12\", \"2018-06-13\"])</code> 应该返回 <code>[\"July 12th\",\"June 13th\"]</code>');",
        "assert.deepEqual(makeFriendlyDates(['2003-08-15', '2009-09-21']), ['August 15th, 2003', 'September 21st, 2009'], 'message: <code>makeFriendlyDates([\"2003-08-15\", \"2009-09-21\"])</code> 应该返回 <code>[\"August 15th, 2003\", \"September 21st, 2009\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2010-10-23', '2011-10-22']), ['October 23rd, 2010', 'October 22nd'], 'message: <code>makeFriendlyDates([\"2010-10-23\", \"2011-10-22\"])</code> 应该返回 <code>[\"October 23rd, 2010\",\"October 22nd\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2008-10-31', '2009-10-31']), ['October 31st, 2008', 'October 31st, 2009'], 'message: <code>makeFriendlyDates([\"2008-10-31\", \"2009-10-31\"])</code> 应该返回 <code>[\"October 31st, 2008\",\"October 31st, 2009\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2004-11-17', '2005-12-25']), ['November 17th, 2004', 'December 25th, 2005'], 'message: <code>makeFriendlyDates([\"2004-11-17\", \"2005-12-25\"])</code> 应该返回 <code>[\"November 17th, 2004\",\"December 25th, 2005\"]</code>.');",
        "assert.deepEqual(makeFriendlyDates(['2001-12-20', '2001-12-20']), ['December 20th, 2001'], 'message: <code>makeFriendlyDates([\"2001-12-20\", \"2001-12-20\"])</code> 应该返回 <code>[\"December 20th, 2001\"]</code>.');",
        "assert.isNotArray(makeFriendlyDates(['2002-12-20', '2001-12-20']), 'message: <code>makeFriendlyDates([\"2002-12-20\", \"2001-12-20\"])</code> 不应该返回数组');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "String.split()",
        "String.substr()",
        "parseInt()"
      ],
      "challengeType": 5
    },
    {
      "id": "a2f1d72d9b908d0bd72bb9f6",
      "title": "Make a Person",
      "description": [
        "用下面给定的方法构造一个对象.",
        "方法有 getFirstName(), getLastName(), getFullName(), setFirstName(first), setLastName(last), and setFullName(firstAndLast).",
        "所有有参数的方法只接受一个字符串参数.",
        "所有的方法只与实体对象交互.",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "var Person = function(firstAndLast) {",
        "    return firstAndLast;",
        "};",
        "",
        "var bob = new Person('Bob Ross');",
        "bob.getFullName();"
      ],
      "solutions": [
        "var Person = function(firstAndLast) {\n\n  var firstName, lastName;\n\n  function updateName(str) {    \n    firstName = str.split(\" \")[0];\n    lastName = str.split(\" \")[1];    \n  }\n\n  updateName(firstAndLast);\n\n  this.getFirstName = function(){\n    return firstName;\n  };\n  \n  this.getLastName = function(){\n    return lastName;\n  };\n  \n  this.getFullName = function(){\n    return firstName + \" \" + lastName;\n  };\n  \n  this.setFirstName = function(str){\n    firstName = str;\n  };\n  \n\n  this.setLastName = function(str){\n    lastName = str;\n  };\n  \n  this.setFullName = function(str){\n    updateName(str);\n  };\n};\n\nvar bob = new Person('Bob Ross');\nbob.getFullName();"
      ],
      "tests": [
        "assert.deepEqual(Object.keys(bob).length, 6, 'message: <code>Object.keys(bob).length</code> 应该返回 6.');",
        "assert.deepEqual(bob instanceof Person, true, 'message: <code>bob instanceof Person</code> 应该返回 true.');",
        "assert.deepEqual(bob.firstName, undefined, 'message: <code>bob.firstName</code> 应该返回 undefined.');",
        "assert.deepEqual(bob.lastName, undefined, 'message: <code>bob.lastName</code> 应该返回 undefined.');",
        "assert.deepEqual(bob.getFirstName(), 'Bob', 'message: <code>bob.getFirstName()</code> 应该返回 \"Bob\".');",
        "assert.deepEqual(bob.getLastName(), 'Ross', 'message: <code>bob.getLastName()</code> 应该返回 \"Ross\".');",
        "assert.deepEqual(bob.getFullName(), 'Bob Ross', 'message: <code>bob.getFullName()</code> 应该返回 \"Bob Ross\".');",
        "assert.strictEqual((function () { bob.setFirstName(\"Haskell\"); return bob.getFullName(); })(), 'Haskell Ross', 'message: <code>bob.getFullName()</code> 应该返回 \"Haskell Ross\" after <code>bob.setFirstName(\"Haskell\")</code>.');",
        "assert.strictEqual((function () { var _bob=new Person('Haskell Ross'); _bob.setLastName(\"Curry\"); return _bob.getFullName(); })(), 'Haskell Curry', 'message: <code>bob.getFullName()</code> 应该返回 \"Haskell Curry\" after <code>bob.setLastName(\"Curry\")</code>.');",
        "assert.strictEqual((function () { bob.setFullName(\"Haskell Curry\"); return bob.getFullName(); })(), 'Haskell Curry', 'message: <code>bob.getFullName()</code> 应该返回 \"Haskell Curry\" 在 <code>bob.setFullName(\"Haskell Curry\")</code> 之后.');",
        "assert.strictEqual((function () { bob.setFullName(\"Haskell Curry\"); return bob.getFirstName(); })(), 'Haskell', 'message: <code>bob.getFirstName()</code> 应该返回 \"Haskell\" 在 <code>bob.setFullName(\"Haskell Curry\")</code> 之后.');",
        "assert.strictEqual((function () { bob.setFullName(\"Haskell Curry\"); return bob.getLastName(); })(), 'Curry', 'message: <code>bob.getLastName()</code> 应该返回 \"Curry\" 在 <code>bob.setFullName(\"Haskell Curry\")</code> 之后.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Closures",
        "Details of the Object Model"
      ],
      "challengeType": 5
    },
    {
      "id": "af4afb223120f7348cdfc9fd",
      "title": "Map the Debris",
      "description": [
        "返回一个数组，其内容是把原数组中对应元素的平均海拔转换成其对应的轨道周期.",
        "原数组中会包含格式化的对象内容，像这样 <code>{name: 'name', avgAlt: avgAlt}</code>.",
        "至于轨道周期怎么求，戳这里 <a href=\"http://en.wikipedia.org/wiki/Orbital_period\" target='_blank'>on wikipedia</a> (不想看英文的话可以自行搜索以轨道高度计算轨道周期的公式).",
        "求得的值应该是一个与其最接近的整数，轨道是以地球为基准的.",
        "地球半径是 6367.4447 kilometers, 地球的GM值是 398600.4418, 圆周率为Math.PI",
        "当你遇到困难的时候，记得查看错误提示、阅读文档、搜索、提问。"
      ],
      "challengeSeed": [
        "function orbitalPeriod(arr) {",
        "  var GM = 398600.4418;",
        "  var earthRadius = 6367.4447;",
        "  return arr;",
        "}",
        "",
        "orbitalPeriod([{name : \"sputnik\", avgAlt : 35873.5553}]);"
      ],
      "solutions": [
        "function orbitalPeriod(arr) {\n  var GM = 398600.4418;\n  var earthRadius = 6367.4447;\n  var TAU = 2 * Math.PI; \n  return arr.map(function(obj) {\n    return {\n      name: obj.name,\n      orbitalPeriod: Math.round(TAU * Math.sqrt(Math.pow(obj.avgAlt+earthRadius, 3)/GM))\n    };\n  });\n}\n\norbitalPeriod([{name : \"sputkin\", avgAlt : 35873.5553}]);\n"
      ],
      "tests": [
        "assert.deepEqual(orbitalPeriod([{name : \"sputnik\", avgAlt : 35873.5553}]), [{name: \"sputnik\", orbitalPeriod: 86400}], 'message: <code>orbitalPeriod([{name : \"sputnik\", avgAlt : 35873.5553}])</code> 应该返回 <code>[{name: \"sputnik\", orbitalPeriod: 86400}]</code>.');",
        "assert.deepEqual(orbitalPeriod([{name: \"iss\", avgAlt: 413.6}, {name: \"hubble\", avgAlt: 556.7}, {name: \"moon\", avgAlt: 378632.553}]), [{name : \"iss\", orbitalPeriod: 5557}, {name: \"hubble\", orbitalPeriod: 5734}, {name: \"moon\", orbitalPeriod: 2377399}], 'message: <code>orbitalPeriod([{name: \"iss\", avgAlt: 413.6}, {name: \"hubble\", avgAlt: 556.7}, {name: \"moon\", avgAlt: 378632.553}])</code> 应该返回 <code>[{name : \"iss\", orbitalPeriod: 5557}, {name: \"hubble\", orbitalPeriod: 5734}, {name: \"moon\", orbitalPeriod: 2377399}]</code>.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Math.pow()"
      ],
      "challengeType": 5
    },
    {
      "id": "a3f503de51cfab748ff001aa",
      "title": "Pairwise",
      "description": [
        "<strong>找到你的另一半</strong>",
        "都说优秀的程序员擅长面向对象编程，但却经常找不到另一半，这是为什么呢？因为你总是把自己局限成为一个程序员，没有打开自己的思维。",
        "这是一个社群的时代啊，在这里你应该找到与你有相同价值观但又互补的另一半。",
        "譬如：你编程能力强，估值11分，如果以20分为最佳情侣来计算，你应该找一个设计能力强，估值为9分的女生。",
        "那么当你遇到一个设计能力为9分的女生，千万别犹豫，大胆去表白。千万别以为后面的瓜比前面的甜哦。",
        "举个例子：有一个能力数组<code>[7,9,11,13,15]</code>，按照最佳组合值为20来计算，只有7+13和9+11两种组合。而7在数组的索引为0，13在数组的索引为3，9在数组的索引为1，11在数组的索引为2。",
        "所以我们说函数：<code>pairwise([7,9,11,13,15],20)</code> 的返回值应该是0+3+1+2的和，即6。",
        "我们可以通过表格来更直观地查看数组中索引和值的关系：",
        "<table class=\"table\"><tr><th><b>Index</b></th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th></tr><tr><td>Value</td><td>7</td><td>9</td><td>11</td><td>13</td><td>15</td></tr></table>",
        "任务：帮右边的pairwise函数实现上面的功能。",
        "当你遇到困难的时候，记得开大招'Read-Search-Ask'。"
      ],
      "challengeSeed": [
        "function pairwise(arr, arg) {",
        "  return arg;",
        "}",
        "",
        "pairwise([1,4,2,3,0,5], 7);"
      ],
      "solutions": [
        "function pairwise(arr, arg) {\n  var sum = 0;\n  arr.forEach(function(e, i, a) {\n    if (e != null) {      \n      var diff = arg-e;\n      a[i] = null;\n      var dix = a.indexOf(diff);\n      if (dix !== -1) {\n        sum += dix;\n        sum += i;\n        a[dix] = null;\n      }  \n    }\n  });\n  return sum;\n}\n\npairwise([1,4,2,3,0,5], 7);\n"
      ],
      "tests": [
        "assert.deepEqual(pairwise([1, 4, 2, 3, 0, 5], 7), 11, 'message: <code>pairwise([1, 4, 2, 3, 0, 5], 7)</code> 应该返回 11.');",
        "assert.deepEqual(pairwise([1, 3, 2, 4], 4), 1, 'message: <code>pairwise([1, 3, 2, 4], 4)</code> 应该返回 1.');",
        "assert.deepEqual(pairwise([1, 1, 1], 2), 1, 'message: <code>pairwise([1, 1, 1], 2)</code> 应该返回 1.');",
        "assert.deepEqual(pairwise([0, 0, 0, 0, 1, 1], 1), 10, 'message: <code>pairwise([0, 0, 0, 0, 1, 1], 1)</code> 应该返回 10.');",
        "assert.deepEqual(pairwise([], 100), 0, 'message: <code>pairwise([], 100)</code> 应该返回 0.');"
      ],
      "type": "bonfire",
      "MDNlinks": [
        "Array.reduce()"
      ],
      "challengeType": 5
    }
  ]
}
